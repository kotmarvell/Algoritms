Ответы:

1. Да, читала.
 - В школе (10-11 класс, когда решала людям домашку по проге и помогала с егэ, это было больно)
 - В вузе (У нас не так много ребят из группы пишут сами, но обычно достаточно интересно посмотреть на другие варианты решения заданий)
 - На работе (По началу, когда я пришла и мне показали то, что уже есть...ощущения были на подобии...господи, что это такое, почему я ничего не понимаю то? Где-то за день разобралась в структуре и где-то через неделю разобралась в самом проекте.)
 Сейчас, лично мне, достаточно интересно смотреть чужое что-то. Как минимум потому что это другой стиль решения.

 2. С#, C++, Python
 Их предназначение? Очень плохо сформулированный вопрос.
 Предназначение любого языка программирования - испольнять последовательность операций, заданных человеком. Это если в широком смысле слова "предназначение".
 А так, если вопрос в том, что на нем можно делать - то даже на том же js можно писать бэк, правда под водой.
 
 Из того, с чем работала лично я...

Я бы не рискнула писать что-то для сайта на с++
На нем писала сервер и олимпиадные задачки

Олимпиадное на С# - это очень больно, честно
С ASP.Net - можно уйти в веб
С WinForms - можно под Desctop (Но это вроде как умирает сейчас)
И консольные приложения
(На работе пытаюсь для распознавания изображения использовать и обработки его. Не сказала бы, что больно, но жуткое ощущение того, что на python было бы проще. Как минимум потому что там намного больше всего для этого есть)

Если брать Python, то можно и в веб, и в олимпиадное (если адекватно написать) и в что-то с математикой.

 3. Что такое компилятор, зачем он нужен?
Штука, которая код в машинный или околомашинный преобразует.
Откомпилированный заранее код обрабатывается быстрее машиной чем интерпритатор это делает без компилляции.
	Почему некоторые обходятся без него?
Потому что можно без него? :)
Но это будет дольше

 4. Что такое фреймворк?
Если объяснять своими словами, то
У нас есть библиотеки, а есть фреймворки
Библиотека - это набор кусочков кода, собранный с одной логикой (работа со строками, работа с файлами) в одном месте
Человек пишет программу и использует в ней эти кусочки

А если брать фреймворк, то это уже написанный готовый  большой кусок программы(основное выполнение), протестированный, для которого мы дописываем отдельные маленькие части (бизнес-логику, запросы к бд или что-то такое)

 5. http - протокол, используемый на сайте. Он является не безопасным. Что бы установить безопасное соединение - используется https. 

 6. Поиск, фид, навигация, профиль, логин-логаут блок, сообщения

 7. Мне очень нравится этот вопрос :)
 Буквально в субботу, на YaTalks, его задали спикеру.
 Выбор того, использовать sql или nosql зависит от конкретной задачи.
 Разница между базами на этих двух языках в том, как они спроектированы, что поддерживают из типов и как хранят информацию. 
 
 Если брать те базы, которые используют SQL, то
 1) Ты можешь адекватно нормализовать таблицы
 2) Хранит структурированные данные
 Сама структура изменяется не часто.
 3) Сама таблица расширяется обычно в глубь
 4) Язык, с которым работает достаточно много компаний

 Если брать не реляционные базы с NoSql, то:
 1) Могуть хранить json (Хотя так же это можно сдеть и в Postgre, но там не так удобно, вроде как)
 2) Расширяются в ширь
 3) Некоторые команды правда проще
 4) Можно менять структуру (Это очень классно, когда ты не знаешь куда все вытечет)
 Из примеров: 
 Если у нас будет таблица с произвольным набором данных, то в не реляционной бд - это можно в одну таблицу, а в реляционной - будет разбито на несколько.
 Если у нас есть справочник с "имя - телефон", то в реляционной это - одно имя, один телефон, что очень удобно
 Но если мы, допустим, захотим добавить ещё один телефон пользователю, то это ещё одна запись
 В не реляционной это можно сделать в ту же, но при этом ты вытаскивать будешь весь документ с данными пользователя, а это не всегда хорошо и классно.
 По итогу: Они оба чудесны, если правильно подобраны под задачу. Иначе только под водой работать можно (Что бы не плакать :))

 8.https://github.com/kotmarvell/Algoritms

 9.
SELECT Products.NAME, Categorys.NAME
FROM Products LEFT JOIN P_Categorys
ON Products.ProductID = P_Categorys.ProductID LEFT JOIN Categorys
ON P_Categorys.CategoryID = Categorys.CategoryID
